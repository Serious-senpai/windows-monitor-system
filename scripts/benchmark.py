# Disclaimer: This script is generated by Gemini.
import argparse
import signal
import subprocess
import sys
import time
import shlex  # Import shlex for robust command parsing
from typing import List

# A list to keep track of all the subprocesses
processes: List[subprocess.Popen] = []
# A flag to prevent the signal handler from running multiple times
shutdown_initiated = False

def signal_handler(sig, frame):
    """
    Handles termination signals by gracefully shutting down all subprocesses.
    This function is designed to be idempotent.
    """
    global shutdown_initiated
    if shutdown_initiated:
        return  # Avoid running shutdown logic multiple times
    shutdown_initiated = True

    print(f"\nSignal {sig} received. Sending SIGINT to all subprocesses...")
    # Iterate over a copy of the list, as it might change
    for p in list(processes):
        if p.poll() is None:  # Check if the process is still running
            try:
                # On Windows, SIGINT is the correct signal for Ctrl+C
                p.send_signal(signal.SIGINT)
            except OSError:
                # This can happen if the process terminates between poll() and send_signal()
                pass
    print("Waiting for all subprocesses to terminate...")

def main():
    """
    Main function to parse arguments, run subprocesses, and manage their lifecycle.
    """
    parser = argparse.ArgumentParser(
        description="Run a command in N subprocesses and terminate them with Ctrl+C or after a timeout."
    )
    parser.add_argument(
        "cmd",
        nargs=argparse.REMAINDER,
        help="The command and its arguments to execute. Can be a single quoted string.",
    )
    parser.add_argument(
        "-n",
        "--num-processes",
        type=int,
        default=1,
        help="The number of subprocesses to run (N).",
    )
    parser.add_argument(
        "-t",
        "--timeout",
        type=int,
        help="Optional timeout in seconds to wait before sending Ctrl+C.",
    )

    args = parser.parse_args()

    if not args.cmd:
        parser.error("The 'cmd' argument is required.")

    # --- FIX: Handle quoted command-line arguments ---
    # If the user provides the command as a single quoted string,
    # use shlex.split to correctly parse it into a command and its arguments.
    if len(args.cmd) == 1:
        command = shlex.split(args.cmd[0])
    else:
        command = args.cmd

    # Register the signal handler for SIGINT (Ctrl+C)
    signal.signal(signal.SIGINT, signal_handler)

    print(f"Starting {args.num_processes} instances of: {' '.join(command)}")
    for i in range(args.num_processes):
        try:
            # --- FIX: Redirect stdout and stderr to DEVNULL ---
            process = subprocess.Popen(
                command,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            processes.append(process)
            time.sleep(0.01)
            print(f"  - Started process {i+1} with PID: {process.pid}")
        except FileNotFoundError:
            print(f"Error: Command not found: {command[0]}", file=sys.stderr)
            if processes:
                signal_handler(signal.SIGINT, None) # Terminate already started processes
            sys.exit(1)
        except Exception as e:
            print(f"An error occurred while starting a process: {e}", file=sys.stderr)
            if processes:
                signal_handler(signal.SIGINT, None)
            sys.exit(1)

    start_time = time.time()
    try:
        print(f"\nRunning... Press Ctrl+C to terminate.")
        if args.timeout:
            print(f"Will automatically terminate after {args.timeout} seconds.")

        # --- FIX: Windows-compatible waiting loop ---
        # signal.pause() is not available on Windows. We use a loop that sleeps,
        # allowing the signal handler to interrupt it or for the timeout to be checked.
        while not shutdown_initiated:
            if args.timeout and (time.time() - start_time) >= args.timeout:
                print("\nTimeout reached.")
                signal_handler(signal.SIGINT, None) # Manually trigger the handler
                break
            time.sleep(0.5)  # Sleep for a short interval

    except KeyboardInterrupt:
        # This block is entered if Ctrl+C is pressed.
        # The signal handler will have already been called.
        pass
    finally:
        # Wait for all processes to complete their shutdown
        for i, p in enumerate(processes):
            return_code = p.wait()
            print(f"  - Process {i+1} (PID: {p.pid}) terminated with return code: {return_code}")
        print("\nAll subprocesses have been terminated.")


if __name__ == "__main__":
    main()
